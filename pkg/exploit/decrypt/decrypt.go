package decrypt

import (
	"fmt"

	"github.com/google/gousb"

	"github.com/freemyipod/wInd3x/pkg/dfu"
	"github.com/freemyipod/wInd3x/pkg/exploit"
	"github.com/freemyipod/wInd3x/pkg/uasm"
)

// Payload creates a payload which decrypts 0x40 bytes from the DFU
// buffer into the DFU buffer using a zero IV and the Global key.
//
// Note: If using CBC, this means the first block will be junk.
//
// TODO(q3k): fix this by allowing to specify any IV. Didn't have luck
// reconstructing CBC this way so far, though...
func Payload(ep *exploit.Parameters) ([]byte, error) {
	insns := ep.DisableICache
	insns = append(insns, ep.AESCall...)
	insns = append(insns, ep.HandlerFooter(ep.DFUBufAddr)...)
	payload := uasm.Program{
		Address: ep.ExecAddr,
		Listing: insns,
	}

	return payload.Assemble(), nil
}

func Trigger(usb *gousb.Device, ep *exploit.Parameters, data []byte) ([]byte, error) {
	if err := dfu.Clean(usb); err != nil {
		return nil, fmt.Errorf("clean failed: %w", err)
	}
	payload, err := Payload(ep)
	if err != nil {
		return nil, fmt.Errorf("failed to generate payload: %w", err)
	}

	dataCopy := make([]byte, 0x40)
	copy(dataCopy, data)
	res, err := exploit.RCE(usb, ep, payload, dataCopy)
	if err != nil {
		return nil, fmt.Errorf("failed to execute decrypt payload: %w", err)
	}

	return res, nil
}
