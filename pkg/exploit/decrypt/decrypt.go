package decrypt

import (
	"fmt"

	"github.com/google/gousb"

	"github.com/freemyipod/wInd3x/pkg/dfu"
	"github.com/freemyipod/wInd3x/pkg/exploit"
	"github.com/freemyipod/wInd3x/pkg/uasm"
)

// Payload creates a payload which decrypts 0x40 bytes from the DFU
// buffer into the DFU buffer using a zero IV and the Global key.
//
// Note: If using CBC, this means the first block will be junk.
//
// TODO(q3k): fix this by allowing to specify any IV. Didn't have luck
// reconstructing CBC this way so far, though...
func Payload(ep *exploit.Parameters) ([]byte, error) {
	insns := []uasm.Statement{
		// Make some stack space to pass args.
		uasm.Sub{Dest: uasm.SP, Src: uasm.SP, Compl: uasm.Immediate(8)},
	}

	if ep.AESFiveParam {
		insns = append(insns,
			// Zero IV.
			uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(0)},
			uasm.Str{Src: uasm.R0, Dest: uasm.Deref(uasm.SP, 0)},

			// Src == dst == DFU buf
			uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(ep.DFUBufAddr)},
			// 0x40 bytes
			uasm.Mov{Dest: uasm.R1, Src: uasm.Immediate(0x40)},
			// Use built-in keys
			uasm.Mov{Dest: uasm.R2, Src: uasm.Immediate(1)},
			// No key (using built-in).
			uasm.Mov{Dest: uasm.R3, Src: uasm.Immediate(0)},
		)
	} else {
		insns = append(insns,
			// Zero IV.
			uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(0)},
			uasm.Str{Src: uasm.R0, Dest: uasm.Deref(uasm.SP, 0)},

			// No key (using built-in).
			uasm.Str{Src: uasm.R0, Dest: uasm.Deref(uasm.SP, 4)},

			// Src == dst == DFU buf
			uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(ep.DFUBufAddr)},
			uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(ep.DFUBufAddr)},
			// 0x40 bytes
			uasm.Mov{Dest: uasm.R2, Src: uasm.Immediate(0x40)},
			// Use built-in keys
			uasm.Mov{Dest: uasm.R3, Src: uasm.Immediate(1)},
		)
	}

	insns = append(insns,
		//// Call decryption.
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(ep.AESHWDec)},
		uasm.Blx{Dest: uasm.LR},

		//// Revert stack.
		uasm.Add{Dest: uasm.SP, Src: uasm.SP, Compl: uasm.Immediate(8)},
		// Fixup LR (after trampoline blx messes it up)
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(ep.ReturnAddr)},
		uasm.Bx{Dest: uasm.LR},
	)

	payload := uasm.Program{
		Address: ep.ExecAddr,
		Listing: insns,
	}

	return payload.Assemble(), nil
}

func Trigger(usb *gousb.Device, ep *exploit.Parameters, data []byte) ([]byte, error) {
	if err := dfu.Clean(usb); err != nil {
		return nil, fmt.Errorf("clean failed: %w", err)
	}
	payload, err := Payload(ep)
	if err != nil {
		return nil, fmt.Errorf("failed to generate payload: %w", err)
	}

	dataCopy := make([]byte, 0x40)
	copy(dataCopy, data)
	if err := exploit.RCE(usb, ep, payload, dataCopy); err != nil {
		return nil, fmt.Errorf("failed to execute decrypt payload: %w", err)
	}

	resBuf := make([]byte, 0x40)
	n, err := usb.Control(0xa1, uint8(dfu.RequestUpload), 0, 0, resBuf)
	if err != nil {
		return nil, fmt.Errorf("failed to read data: %w", err)
	}
	if n != 0x40 {
		return nil, fmt.Errorf("only got %x bytes", n)
	}

	return resBuf, nil
}
